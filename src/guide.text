1. Minimize State Usage:
   - Avoid using state wherever possible. Instead, use DOM references (`refs`) when managing the UI 
   and direct interactions with elements.
   
2. Do Not Recreate Backend Data:
   - It’s inefficient to fetch data from the backend and then store it in state unnecessarily. Treat the 
     backend as the single source of truth.
   - Storing backend data in state leads to increased complexity, potential bugs, and makes the app slower,
     especially when the frontend and backend become out of sync.
   - So, if you are building a backend or request the backend dev to always return back the fresh processed 
     data from the backend and update state using that. Also, always make use of prev state when updating 
     the state else if someone does multiple operations even though with unique components, the update 
     will be out of sync.

3. Handle Asynchronous Data with Libraries:
   - For complex asynchronous data flows, use external libraries like TanStack Query (React Query) to 
     handle fetching, caching, and synchronization.
   
4. Backend as the Source of Truth:
   - Whenever you need to process data, utilize backend APIs. Use the fresh response from the backend to 
     update the UI.
   - Avoid implementing backend logic or functionality in the frontend. It’s a waste of time and mental 
     effort, offering negligible performance gains.
   - In modern applications, network latency is rarely a bottleneck, and syncing frontend state for minor 
     speed improvements isn’t worth it.

5. Error Handling in Asynchronous Data:
   - If you try to sync frontend state before receiving backend responses, errors can occur. It’s better 
     to wait for the backend response before updating the frontend. Otherwise, resetting the UI back to 
     its previous state becomes tricky and error-prone.

6. Keep the Frontend Simple:
   - Over complicating frontend state management makes development harder and introduces more bugs. Focus 
     on what frontend is really for: displaying data and providing a smooth user experience across devices.

7. Use Context Appropriately:
   - Use context when a piece of state is needed by multiple components. For isolated state needs, use props.
   - Context acts like a global variable but should be used wisely to avoid unnecessary re-renders 
     and complexity.

8. Dynamic Components and State Management:
   - In cases like a Todo app, separate the UI from state management. Don’t initialize state 
     and references for actions (like updating or deleting) when the app first loads.
   - Instead, create custom hooks for dynamic components that need their own isolated states 
     and references. This ensures that each dynamic component (e.g., a Todo item) has its own fresh
     and independent state management.

9. Generalize Components:
   - Avoid creating components that are too specific to a single use case. Instead, create 
     generalized components that can be reused across the application.
   - For example, a `Error` component can be used in multiple places with different text, 
     styles, and click handlers. A loading spinner can be used in multiple places with different
     sizes, colors, and animations.

10. Create As Many Components as Necessary:
    - Break down your application into as many components as necessary, even for something as small 
      as a button. If there's complex functionality involved, it's best to create a dedicated component. 
    - This approach ensures better reusability, cleaner code, and makes debugging easier. In React, 
      components are the core building blocks, and splitting up complex logic into individual components 
      helps in maintaining clarity and organization.

11. Managing Race Conditions:

    - Even though we are making use of prev state using the functional setState, there are still
      chances that the state might get out of sync when multiple operations are performed.
    - Eg: if the todos, each unique with its own delete and update etc, are performed simultaneously
      then the state may get out of sync, especially in the case of delete operation.
    - To handle such cases, we can make use of the `useReducer` hook which is a more powerful alternative
      to the `useState` hook. It allows you to define a reducer function that receives the current state 
      and an action, and returns a new state. This way, you can handle complex state updates more 
      efficiently.
    - other option is to introduce a slight custom delay to the fn
        eg: const removeTodo = (id) => {
            setTodos((prev) => prev.filter((todo) => todo.id !== id));
            setTimeout(() => {}, 100);  // Adjust the delay as needed
          };
    

### Conclusion:
The goal is to reduce unnecessary complexity in frontend development, especially when the backend 
can handle much of the heavy lifting. By treating the backend as the source of truth and minimizing 
state, you can build fast, maintainable, and bug-free applications.