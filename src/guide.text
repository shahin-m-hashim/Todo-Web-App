How to build a fast, maintainable, and bug-free frontend in React:

1. Create your webpages in one single component first
2. Make the webpage responsive using tailwind css and test it
3. Now start breaking down the webpage into smaller components.

Why this is  very important ?
  If you create components from the get go , it will be extremely difficult to 
  make the webpage responsive. You will most likely waste your time in debugging
  and managing state across multiple components rather than actually focusing on
  the most important part - a responsive frontend. 

# Once you done the above steps and have a responsive webpage, 
# you can now go on with the react way of doing things as below:

1. Minimize State Usage:
   - Avoid using state wherever possible. Instead, use DOM references (`refs`) when managing the UI 
   and direct interactions with elements.
   
2. Do Not Recreate Backend Data:
   - It’s inefficient to fetch data from the backend and then store it in state unnecessarily. Treat the 
     backend as the single source of truth.
   - Storing backend data in state leads to increased complexity, potential bugs, and makes the app slower,
     especially when the frontend and backend become out of sync.
   - So, if you are building a backend or request the backend dev to always return back the fresh processed 
     data from the backend and update state using that. Also, always make use of prev state when updating 
     the state else if someone does multiple operations even though with unique components, the update 
     will be out of sync.

3. Handle Asynchronous Data with Libraries:
   - For complex asynchronous data flows, use external libraries like TanStack Query (React Query) to 
     handle fetching, caching, and synchronization.
   
4. Backend as the Source of Truth:
   - Whenever you need to process data, utilize backend APIs. Use the fresh response from the backend to 
     update the UI.
   - Avoid implementing backend logic or functionality in the frontend. It’s a waste of time and mental 
     effort, offering negligible performance gains.
   - In modern applications, network latency is rarely a bottleneck, and syncing frontend state for minor 
     speed improvements isn’t worth it.

5. Error Handling in Asynchronous Data:
   - If you try to sync frontend state before receiving backend responses, errors can occur. It’s better 
     to wait for the backend response before updating the frontend. Otherwise, resetting the UI back to 
     its previous state becomes tricky and error-prone.

6. Keep the Frontend Simple:
   - Over complicating frontend state management makes development harder and introduces more bugs. Focus 
     on what frontend is really for: displaying data and providing a smooth user experience across devices.

7. Use Context Appropriately:
   - Use context when a piece of state is needed by multiple components. For isolated state needs, use props.
   - Context acts like a global variable but should be used wisely to avoid unnecessary re-renders 
     and complexity.

8. Dynamic Components and State Management:
   - In cases like a Todo app, separate the UI from state management. Don’t initialize state 
     and references for actions (like updating or deleting) when the app first loads.
   - Instead, create custom hooks for dynamic components that need their own isolated states 
     and references. This ensures that each dynamic component (e.g., a Todo item) has its own fresh
     and independent state management.

9. Generalize Components:
   - Avoid creating components that are too specific to a single use case. Instead, create 
     generalized components that can be reused across the application.
   - For example, a `Error` component can be used in multiple places with different text, 
     styles, and click handlers. A loading spinner can be used in multiple places with different
     sizes, colors, and animations.

10. Create As Many Components as Necessary:
    - Break down your application into as many components as necessary, even for something as small 
      as a button. If there's complex functionality involved, it's best to create a dedicated component. 
    - This approach ensures better reusability, cleaner code, and makes debugging easier. In React, 
      components are the core building blocks, and splitting up complex logic into individual components 
      helps in maintaining clarity and organization.

11. Managing Race Conditions:

    - Even though we are making use of prev state using the functional setState, there are still
      chances that the state might get out of sync when multiple operations are performed.
    - Eg: if the todos, each unique with its own delete and update etc, are performed simultaneously
      then the state may get out of sync, especially in the case of delete operation.
    - To handle such cases, we can make use of the `useReducer` hook which is a more powerful alternative
      to the `useState` hook. It allows you to define a reducer function that receives the current state 
      and an action, and returns a new state. This way, you can handle complex state updates more 
      efficiently.
    - other option is to introduce a slight custom delay to the fn
        eg: const removeTodo = (id) => {
            setTodos((prev) => prev.filter((todo) => todo.id !== id));
            setTimeout(() => {}, 100);  // Adjust the delay as needed
          };
    
PERFORMANCE OPTIMIZATION:

*** Biggest React Challenge - Balancing UI/UX tree, state tree and performance ***

Modern websites and applications are complex related data scattered all around or in different places
to make them look more visually appealing and interactive. Animations are best examples. 

Whereas in state level we can group related data into objects and arrays, but its really hard or
not possible to change the ui based on this grouping.

So, a dummy div element acting as parent to group related data will work, but still this 
is hard due to html and css styling limitations.

eg :- 

state :
const user - {
  id: 1,
  age: 25
  isOnline: true,
  name: 'John Doe',
  email: 'john@gmail.com',
  profilePic: 'https://example.com/john.jpg'
  bio: 'Lorem ipsum dolor sit.',
}


UI/UX:
<div class="absolute top-0 ">
  <img src={user.profilePic}>
</div>

<div class="absolute top-0 right-0">
  <h1>{user.name}</h1>
  <p>{user.bio}</p>
</div>

<div class="absolute bottom-0 right-0">
  <p>{user.email}</p>
</div>


grouping these ui elements into a single div element will mess up the styling, positioning
and entire ui will be affected.

Other way is to use a provider component to group related data and consume it in the child components.
But this will lead to performance issues as the provider component will rerender all the child components.

So, to begin

1. Understand React Render Life Cycle - 
    - React components re-render when their state or props change. 
    - When a react component(which is typically a function) is called, it returns a JSX which is then 
      rendered by React. Life cycle consists of 3 phases: Mounting, Updating and Unmounting.
      * mounting - when the component is first rendered
      * updating - when the component is re-rendered
      * unmounting - when the component is removed from the DOM
    - React uses a virtual DOM to optimize rendering. It compares the current virtual DOM with the previous
      one and only updates the actual DOM with the changes. This makes React fast and efficient.

2. Understand hooks based on performance - 
    - useState - rerenders the component when the state changes
    - useEffect - runs on every render, but you can control when it runs by passing a dependency array
    - useRef - doesn't trigger any re renders. Best for direct dom manipulation, tracking and monitoring
      global data like currently editing todos array
    - useMemo - memoizes the result of a function and only recalculates when the dependencies change
    - useCallback - memoizes a function and only recalculates when the dependencies change. Wrap a 
      function that isn't a setter function like setState. 
    - React.memo - ultimate performance optimization. It's a higher order component that memoizes the 
      component and only re-renders when the props change.
    
3. Understand contexts - 
    - Contexts are a way to pass data through the component tree without having to pass props down 
      manually at every level.
    - Comes with major performance impact on all consuming components since any state in the context 
      provider will rerun the provider which in turn reruns all the consuming components.


Best approach:

  - Once you have a responsive webpage and broken down the webpage into smaller components,
    look for a perfect parent component and pass down the data as props to the child components.
  
  - Wrap major child components like a big list or forms etc which will have its own complex state
    and logic using the `React.memo` to avoid unnecessary re-renders with minute changes like 
    toggling or theme switching.

  - Make sure to wrap any fn other than setters using useCallback to avoid unnecessary re-renders even 
    after memoizing child components.
  
  - Memoize stale values other than states and useRef like a initial update form with useMemo to 
    avoid re-calculating the values on every re-render.

  - Create Providers only when necessary for cases like an entire list which no matter what will change
    in most cases. 

  - Finally to debug and make sure console out each component like console.log('ComponentName') to 
    understand the re-renders and performance issues, or use the React Dev Tools to profile the app.

### Conclusion:

The goal is to reduce unnecessary complexity in frontend development, especially when the backend 
can handle much of the heavy lifting. By treating the backend as the source of truth and minimizing 
state, you can build fast, maintainable, and bug-free applications.